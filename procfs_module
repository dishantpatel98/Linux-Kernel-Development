Procfs is a internal   kernel static module,there is no  support, for dynamic kernel module, for this component. 

 --->since it is one of the most essential 
         kernel component, disabling is 
         unacceptable  
-->this document describes the architecture and 
  design of procfs component/subsystem/module
  
       this frame-work /sub-system
       --->exports system APIs and their rules
       --->provides system objects and their 
           rules 
       --->maintains system lists and meta-data
       --->supports managing call backs  

- procfs is a "special file system resident" 
  , in main memory/system-space - does not store data/
  user-data/application-data  - 
  does manage special files, known as "procfs 
  files and directories" - 
  in Unix/Linux language, it is known 
  as "a pseudo file system/synthetic file system" - 
  "it does support 
  meta-data(data used to manage)" , 
  "not stored file data" - only meta-data
  is stored, in these file systems, "not actual data" - 
    - it is a "static kernel module" that is 
      "registered" with 
      "VFS layer" - "VFS layer" is connected to 
      "system call interface layer"

          there is 
          a virtual file switch(VFS) and 
          this is linked/registered to
          system call interface layer
          
          procfs component 
          is registered with VFS layer
      --->similarly, other system components/ 
          modules are registered, with procfs
          layer          
-->Linux manages to support multiple filesystem types.

The idea behind the Virtual Filesystem is to put a wide range of information in the
kernel to represent many different types of filesystems;

The Linux virtual file system or virtual file system generally is a layer that sits on the top of your actual file system which allows the user to access different types of file systems, you can think of virtual file system as an interface between the kernel and the actual file system.
The proc file system is a virtual file system which is mounted on /proc directory.

There is no real file system exists on /proc, it’s a virtual layer that is used for dealing with the kernel functionalities.

For example, to get the processor specifications, type the following command:

$ cat /proc/cpuinfo

This is a very powerful and easy way to query Linux kernel.

Notice that if you check the size of the file in /proc directory, you will find that all file sizes are 0, because as we said they don’t exist on the disk.

When you type cat /proc/cpuinfo command, a file is dynamically created to show you the CPU info.

The only file that has a size in /proc directory is /proc/kcore file, which shows the RAM content. Actually, this file isn’t occupying any space on the disk.

Writing to Proc Files

As we’ve seen, we can read the content of proc files, but some of them are writable, so we can write to them to change some functionality.

For example, this  /proc/sys/net/ipv4/ip_forward file controls IP forwarding in case you have multiple network cards.

You can change the value of this file like this:

$ echo "1" > /proc/sys/net/ipv4/ip_forward

Keep in mind that when you change any file or value under /proc directory there is no validation of what you are doing, you may crash your system if you type a wrong setting.

The previous modification to the /proc/sys/net/ipv4/ip_forward entry will not survive after rebooting since you are not writing to a file, this is a virtual file system, means change happens to the memory.

If you list the files in /proc directory, you’ll notice a lot of directories which have numeric names, these directories contain information about the running processes and the numeric value is the corresponding process ID.

You can check the consumed resources by a specific process from these directories.

If you take a look at the folder named 1, it belongs to the init process or systemd (like CentOS 7) which is the first process runs When Linux starts.

$ ls -l /proc/1
The /proc/1/exe  file is a symbolic link to  /lib/systemd/systemd binary or /sbin/init in other systems that use init binary.

The Virtual Filesystem (also known as Virtual Filesystem Switch or VFS) is a kernel
software layer that handles all system calls related to a standard Unix filesystem. Its
main strength is providing a common interface to several kinds of filesystems.

The VFS is an abstraction layer between the application program and the filesystem implementations
For instance, let’s assume that a user issues the shell command:
 
$ cp /floppy/TEST /tmp/test

where /floppy is the mount point of an MS-DOS diskette and /tmp is a normal Second
Extended Filesystem (Ext2) directory. The VFS is an abstraction layer between the
application program and the filesystem implementations (see Figure 12-1(a)).
Therefore, the cp program is not required to know the filesystem types of /floppy/
TEST and /tmp/test.
What is Metadata?
-->Metadata is "data that provides information about other data".[1] In short, it's data about data. 


Instead, cp interacts with the VFS by means of generic system calls known to anyone who has done Unix programming.

file IO/IO  system call 
      APIs of system library can be used to 
      access procfs layer and its services, 
      using layering and modularity 

- in terms of services, "procfs supports 
      procfs directories and files" - mainly, 
      "procfs files are the main services" - 
      so, "a component/module can register 
      with procfs to request for a one or 
      more procfs files to created and 
      managed on behalf the kernel component/
      module"
- for the procfs services/files to be used, 
      "VFS/system call interface layer / system 
      library/file IO system calls" are needed - 
      specifically, VFS is needed to support 
      files /active files , for procfs services

--->applications/processes/threads
      ------>file IO/ IO system calls(system library) 
              ----->system call interface layer
                    ---->VFS layer
                         ------>procfs 
                                 ---> a specific 
                                      kernel component/
                                      modulei

   ---->this specific kernel modulei can 
         be our custom module, as well - 
         say, it can be a device driver or
         another embedded sw module 
 
  we will 
     be seeing certain core components, like
     buddy system allocators/sub-system and 
     slab-allocators/sub-system will using 
     the services of procfs,
 
- procfs mainly supports special files/pseudo files, 
      known as procfs files - these do not 
      store data/but store meta-data - 
      rather, they maintain 
      certain system object(s)(meta-data) and 
      a set of call backs - these system objects/
      meta-data and call backs enable a  
      procfs file to export system data 
      of kernel components/modules or 
      custom modules/drivers to the user-space   
      - the system data is typically exported
      from the kernel modules, that register
      with procfs
    - in most cases, procfs files will be 
      readonly - meaning, just export data 
      from kernel modules/components to 
      user-space - in certain cases, they 
      may be read/write, where we can update 
      data from user-space to the system space
     --->procfs files are created, using 
           system APIs of procfs and system objects
      
     ---->in many cases, we need to create one or 
     more project specific procfs directories
     and under these procfs directories, we
     will create one or more project files
     
---->as part of the init method, the first 
     system API is proc_mkdir(p1, p2); 
        --->p1 is the name of the new procfs 
            directory 
        --->p2 will be the pointer to a 
            struct proc_dir_entry{} system object of 
            the parent procfs directory 
---->as part of the init method, the first 
     system API is proc_mkdir(p1, p2); 
        --->p1 is the name of the new procfs 
            directory 
        --->p2 will be the pointer to a 
            struct proc_dir_entry{} system object of 
            the parent procfs directory 
--->a struct proc_dir_entry{} object is set-up 
    , for every procfs directory and procfs file 
    created - this system object maintains 
    meta-data of any procfs directory instance 
    or procfs file instance 
refer to create_proc_entry()
     or related system API - this system API and 
     other related system APIs are exported by 
     procfs layer/module - exporting is a kernel 
     technique due to which dynamic modules 
     can access services/system APIs of kernel 
     modules/components
--->in our context, our custom dynamic module
         will be accessing system APIs of 
         procfs layer and other such components  
- internally, this system API will create a
     system object, which will be representing 
     the procfs file - at the kernel level, this 
     system object is the one really representing 
     this procfs file, but in user-space we will 
     be seeing an equivalent pathname/file name - the 
     object is of the 
             type struct proc_dir_entry{}
--->in the system-space, procfs files/directories
    are set-up, as system-objects and managed, 
    but in the user-space, procfs files/directories
    are exported, as file-names/path-names 
    
    --->how are these mapped ?? how are these
        linked ?? 
         --->VFS does a major job, in 
             mapping/linking such entities 
         --->VFS does such linking/mapping 
             jobs, for other file-systems/
             directories/files, as well     

   - in the procfs layer/module, every file 
     and directory is represented, using 
     struct proc_dir_entry{} object - all 
     struct proc_dir_entry{} objects of a 
     set of files under a directory will be
     managed, in the struct proc_dir_entry{}
     of the parent procfs directory - this 
     set-up/hierarchy  is part of the frame-work
