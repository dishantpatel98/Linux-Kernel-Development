The operating system is considered the parts of the system
responsible for basic use and administration.This includes the kernel and device drivers,
boot loader, command shell or other user interface, and basic file and system utilities.
The basics of a Linux system are the kernel, C library, toolchain, and basic system utilities, such as a login process and shell.

The user interface is the outer-most portion of the operating system, the kernel is the innermost. It is the core internals;
the software that provides basic services for all other parts of the system, manages hard-
ware, and distributes system resources.The kernel is sometimes referred to as the
supervisor, core, or internals of the operating system.

Typical components of a kernel are interrupt handlers to service interrupt requests, a scheduler to share processor time
among multiple processes, a memory management system to manage process address
spaces, and system services such as networking and interprocess communication.

Modern systems with protected memory management units, the kernel typically resides in
an elevated system state compared to normal user applications.This includes a protected
memory space and full access to the hardware.This system state and memory space is collectively referred to as kernel-space.
Conversely, user applications execute in user-space.

When executing kernel code, the system is in kernel-space executing in kernel mode.When running a regular process, the system is in user-space executing in user mode.

Applications running on the system communicate with the kernel via system calls.
An application typically calls functions in a library—for example, the C
library—that in turn rely on the system call interface to instruct the kernel to carry out
tasks on the application’s behalf. Some library calls provide many features not found in the
system call, and thus, calling into the kernel is just one step in an otherwise large function.

Still other C library functions, such as strcpy() , should (one hopes) make no direct use
of the kernel at all.

When an application executes a system call, we say that the kernel is
executing on behalf of the application. Furthermore, the application is said to be executing a
system call in kernel-space, and the kernel is running in process context.This relationship—
that applications call into the kernel via the system call interface—is the fundamental manner in 
which applications get work done.

The kernel also manages the system’s hardware. Nearly all architectures, including all
systems that Linux supports, provide the concept of interrupts.When hardware wants to
communicate with the system, it issues an interrupt that literally interrupts the processor,
which in turn interrupts the kernel.A number identifies interrupts and the kernel uses
this number to execute a specific interrupt handler to process and respond to the interrupt.
For example, as you type, the keyboard controller issues an interrupt to let the system
know that there is new data in the keyboard buffer.The kernel notes the interrupt num-
ber of the incoming interrupt and executes the correct interrupt handler.The interrupt
handler processes the keyboard data and lets the keyboard controller know it is ready for
more data.


In many operating systems, including Linux,
the interrupt handlers do not run in a process context. Instead, they run in a special
interrupt context that is not associated with any process.This special context exists solely to
let an interrupt handler quickly respond to an interrupt, and then exit.

In fact, in Linux, we can generalize that each processor is doing exactly one of three things at any given moment:

1)In user-space, executing user code in a process
2)In kernel-space, in process context, executing on behalf of a specific process
3)In kernel-space, in interrupt context, not associated with a process, handling an interrupt


Monolithic Kernel Versus Microkernel Designs

##We can divide kernels into two main schools of design: the monolithic kernel and the micro-
kernel. (A third camp, exokernel, is found primarily in research systems.)

-->Monolithic kernels are the simpler design of the two, and all kernels were designed in this
manner until the 1980s. Monolithic kernels are implemented entirely as a single process
running in a single address space. Consequently, such kernels typically exist on disk as sin-
gle static binaries. All kernel services exist and execute in the large kernel address space.
Communication within the kernel is trivial because everything runs in kernel mode in the
same address space: The kernel can invoke functions directly, as a user-space application
might. Proponents of this model cite the simplicity and performance of the monolithic
approach. Most Unix systems are monolithic in design.

-->Microkernels, on the other hand, are not implemented as a single large process. Instead,
the functionality of the kernel is broken down into separate processes, usually called
servers. Ideally, only the servers absolutely requiring such capabilities run in a privileged exe-
cution mode. The rest of the servers run in user-space. All the servers, though, are sepa-
rated into different address spaces. Therefore, direct function invocation as in monolithic
kernels is not possible. Instead, microkernels communicate via message passing: An inter-
process communication (IPC) mechanism is built into the system, and the various servers
communicate with and invoke “services” from each other by sending messages over the IPC
mechanism. The separation of the various servers prevents a failure in one server from
bringing down another. Likewise, the modularity of the system enables one server to be
swapped out for another.

Linux is a monolithic kernel; that is, the Linux kernel executes in a single address space
entirely in kernel mode. Linux, however, borrows much of the good from microkernels: Linux
boasts a modular design, the capability to preempt itself (called kernel preemption), support
for kernel threads, and the capability to dynamically load separate binaries (kernel modules)
into the kernel image. Conversely, Linux has none of the performance-sapping features that
curse microkernel design: Everything runs in kernel mode, with direct function invocation—
not message passing—the modus of communication. Nonetheless, Linux is modular,
threaded, and the kernel itself is schedulable.

A handful of notable differences exist between the Linux kernel and classic
Unix systems:

1)Linux supports the dynamic loading of kernel modules.Although the Linux kernel
is monolithic, it can dynamically load and unload kernel code on demand.

2)Linux has symmetrical multiprocessor (SMP) support.Although most commercial
variants of Unix now support SMP, most traditional Unix implementations did not.

3)The Linux kernel is preemptive. Unlike traditional Unix variants, the Linux kernel
can preempt a task even as it executes in the kernel. Of the other commercial Unix
implementations, Solaris and IRIX have preemptive kernels, but most Unix kernels
are not preemptive.

4)Linux takes an interesting approach to thread support: It does not differentiate
between threads and normal processes.To the kernel, all processes are the same—
some just happen to share resources.

5)Linux provides an object-oriented device model with device classes, hot-pluggable
events, and a user-space device filesystem (sysfs).
Linux ignores some common Unix features that the kernel developers consider
poorly designed, such as STREAMS, or standards that are impossible to cleanly
implement.

6)Linux is free in every sense of the word.The feature set Linux implements is the
result of the freedom of Linux’s open development model. If a feature is without
merit or poorly thought out, Linux developers are under no obligation to imple-
ment it.To the contrary, Linux has adopted an elitist attitude toward changes: Mod-
ifications must solve a specific real-world problem, derive from a clean design, and
have a solid implementation. Consequently, features of some other modern Unix
variants that are more marketing bullet or one-off requests, such as pageable kernel
memory, have received no consideration.

This are the limitation/issues with kernel:

1)The kernel has access to neither the C library nor the standard C headers.
2)The kernel is coded in GNU C.
3)The kernel lacks the memory protection afforded to user-space.
4)The kernel cannot easily execute floating-point operations.
5)The kernel has a small per-process fixed-size stack.
6)Because the kernel has asynchronous interrupts, is preemptive, and supports SMP,
synchronization and concurrency are major concerns within the kernel.
Portability is important.

1-->
The full C library—or even a decent subset of it—is too large and too inefficient for the kernel.
Many of the usual libc functions are implemented inside the kernel. For
example, the common string manipulation functions are in lib/string.c . Just include
the header file <linux/string.h> and have at them.

When I talk about header files in this book, I am referring to the kernel header files that are
part of the kernel source tree. Kernel source files cannot include outside headers, just as
they cannot use outside libraries.

The base files are located in the include/ directory in the root of the kernel source tree. For
example, the header file <linux/inotify.h> is located at include/linux/inotify.h in
the kernel source tree.

A set of architecture-specific header files are located in arch/<architecture>/include/asm
in the kernel source tree. For example, if compiling for the x86 architecture, your architec-
ture-specific headers are in arch/x86/include/asm . Source code includes these headers
via just the asm/ prefix, for example <asm/ioctl.h> .

The kernel does not have access to printf() , but it does provide printk() , which works pretty much the same as
its more familiar cousin.The printk() function copies the formatted string into the kernel log buffer, 
which is normally read by the syslog program.

One notable difference between printf() and printk() is that printk() enables you
to specify a priority flag.This flag is used by syslogd to decide where to display kernel
messages. Here is an example of these priorities:

-->printk(KERN_ERR "this is an error!\n");

Note there is no comma between KERN_ERR and the printed message.This is intentional; 
the priority flag is a preprocessor-define representing a string literal, which is con-
catenated onto the printed message during compilation.

Perhaps surprisingly, the kernel is not programmed in strict ANSI C.Instead, where applicable, the
kernel developers make use of various language extensions available in gcc (the GNU
Compiler Collection, which contains the C compiler used to compile the kernel and
most everything else written in C on a Linux system).

The gcc C compiler enables the embedding of assembly instructions in otherwise normal
C functions.This feature, of course, is used in only those parts of the kernel that are
unique to a given system architecture.

###Inline Assembly
-->an inline assembler is a feature of some compilers that allows low-level code written in assembly language to be embedded within a program, among code that otherwise has been compiled from a higher-level language such as C or Ada. 
The asm() compiler directive is used to inline assembly code. For example, this inline
assembly directive executes the x86 processor’s rdtsc instruction, which returns the value
of the timestamp ( tsc ) register:
unsigned int low, high;

The embedding of assembly language code is usually done for one of three reasons:

1)Optimization: Programmers can use assembly language code to implement the most performance-sensitive parts of their program's algorithms, code that is apt to be more efficient than what might otherwise be generated by the compiler.

2)Access to processor specific instructions: Most processors offer special instructions, such as Compare and Swap and Test and Set instructions which may be used to construct semaphores or other synchronization and locking primitives. Nearly every modern processor has these or similar instructions, as they are necessary to implement multitasking. Examples of specialized instructions are found in the SPARC VIS, Intel MMX and SSE, and Motorola Altivec instruction sets.

3)System calls: High-level languages rarely have a direct facility to make arbitrary system calls, so assembly code is used. 

 Lets understand each of them in detail:
 
1) System call:
Calling an operating system directly is generally not possible under a system using protected memory. The OS runs at a more privileged level (kernel mode) than the user (user mode); a (software) interrupt is used to make requests to the operating system. This is rarely a feature in a higher-level language, and so wrapper functions for system calls are written using inline assembler. 

A wrapper function is a subroutine in a software library or a computer program whose main purpose is to call a second subroutine[1] or a system call with little or no additional computation. Wrapper functions are used to make writing computer programs easier by abstracting away the details of a subroutine's underlying implementation. 

The following C code example shows a system call wrapper in AT&T assembler syntax, using the GNU Assembler. Such calls are normally written with the aid of macros; the full code is included for clarity.

The format of basic inline assembly is very straightforward:

asm (<assembly code>);

Example: Refer https://en.wikipedia.org/wiki/Inline_assembler for more detail

What is asm?
-->The asm keyword allows you to embed assembler instructions within C code. GCC provides two forms of inline asm statements. A basic asm statement is one with no operands (see Basic Asm), while an extended asm statement (see Extended Asm) includes one or more operands. The extended form is preferred for mixing C and assembly language within a function, but to include assembly language at top level you must use basic asm. 

Which assembly instructin set is used now a days ?
-->x86 is a family of instruction set architectures which was developed in 1972 and still used.It is the collobration
of intel and AMD which supports lots of processors.


The Linux kernel is written in a mixture of C and assembly, with assembly relegated
to low-level architecture and fast path code.The vast majority of kernel code is pro-
grammed in straight C

When compiling an assembly statement on Linux*, the compiler simply emits the asm-template to the assembly file after making any necessary operand substitutions. The compiler then calls the GNU* assembler to generate machine code. In contrast, on Windows* the compiler itself must assemble the text contained in the asm-template string into machine code. In essence, the compiler contains a built-in assembler. 

The GNU Assembler, commonly known as gas or simply as, its executable name, is the assembler used by the GNU Project. It is the default back-end of GCC. 

-->kernel memory is not pageable.Therefore, every byte of memory you
consume is one less byte of available physical memory. Keep that in mind the next time
you need to add one more feature to the kernel!



$$$Process and Threads
--->Linux has a unique implementation of threads: It does not differentiate between
threads and processes.To Linux, a thread is just a special kind of process.

--->On modern operating systems, processes provide two virtualizations: a virtualized
processor and virtual memory.The virtual processor gives the process the illusion that it
alone monopolizes the system, despite possibly sharing the processor among hundreds of
other processes.

--->In contemporary Linux kernels, fork() is actually implemented via the clone() sys-
tem call

--->Finally, a program exits via the exit() system call.This function terminates the process
and frees all its resources.A parent process can inquire about the status of a terminated
child via the wait4() 1 system call, which enables a process to wait for the termination of
a specific process.When a process exits, it is placed into a special zombie state that repre-
sents terminated processes until the parent calls wait() or waitpid() .

Another name for a process is a task.

$$$Process Descriptor and the Task Structure
-->The kernel stores the list of processes in a circular doubly linked list called the task list. 2
Each element in the task list is a process descriptor of the type struct task_struct , which
is defined in <linux/sched.h> .The process descriptor contains all the information about
a specific process.

The task_struct is a relatively large data structure, at around 1.7 kilobytes on a 32-bit
machine.This size, however, is quite small considering that the structure contains all the
information that the kernel has and needs about a process.

--> struct task_struct{               //Process Control Block
struct thread_info;
...
....
Total 1kb 
}
-->struct thread_info {
....
}



Inside the kernel, tasks are typically referenced directly by a pointer to their
task_struct structure. In fact, most kernel code that deals with processes works directly
with struct task_struct . Consequently, it is useful to be able to quickly look up the
process descriptor of the currently executing task, which is done via the current macro.

$$$process state
Each process on the system is in exactly one of five different states.This
value is represented by one of five flags:

1)TASK_RUNNING —The process is runnable; it is either currently running or on a run-
queue waiting to run (runqueues are discussed in Chapter 4).This is the only possi-
ble state for a process executing in user-space; it can also apply to a process in
kernel-space that is actively running.

2)TASK_INTERRUPTIBLE —The process is sleeping (that is, it is blocked), waiting for
some condition to exist.When this condition exists, the kernel sets the process’s
state to TASK_RUNNING .The process also awakes prematurely and becomes runnable
if it receives a signal.


3)TASK_UNINTERRUPTIBLE —This state is identical to TASK_INTERRUPTIBLE except
that it does not wake up and become runnable if it receives a signal.This is used in
situations where the process must wait without interruption or when the event is
expected to occur quite quickly. Because the task does not respond to signals in
this state, TASK_UNINTERRUPTIBLE is less often used than TASK_INTERRUPTIBLE

4)__TASK_TRACED —The process is being traced by another process, such as a debug-
ger, via ptrace.

5)__TASK_STOPPED —Process execution has stopped; the task is not running nor is it
eligible to run.This occurs if the task receives the SIGSTOP , SIGTSTP , SIGTTIN , or
SIGTTOU signal or if it receives any signal while it is being debugged.

Kernel code often needs to change a process’s state.The preferred mechanism is using
set_task_state(task, state);
/* set task ‘task’ to state ‘state’ */
This function sets the given task to the given state. If applicable, it also provides a
memory barrier to force ordering on other processors. (This is only needed on SMP sys-
tems.) Otherwise, it is equivalent to
task->state = state;

System calls and exception handlers are well-defined interfaces into the kernel.A
process can begin executing in kernel-space only through one of these interfaces—all
access to the kernel is through these interfaces.

$$$Process Family Tree
--->All processes are descendants of the init process, whose PID is one.The kernel starts
init in the last step of the boot process.The init process, in turn, reads the system
initscripts and executes more programs, eventually completing the boot process.

Consequently, give the current process, it is possible to obtain the process
descriptor of its parent with the following code:

/* struct task_struct *my_parent = current->parent;   */

In fact, you can follow the process hierarchy from any one process in the system to any
other. Oftentimes, however, it is desirable simply to iterate over all processes in the system.
This is easy because the task list is a circular, doubly linked list.

$$$Copy-on-Write
Traditionally, upon fork(), all resources owned by the parent are duplicated and the
copy is given to the child.This approach is naive and inefficient in that it copies much
data that might otherwise be shared.Worse still, if the new process were to immediately
execute a new image, all that copying would go to waste. In Linux, fork() is imple-
mented through the use of copy-on-write pages. Copy-on-write (or COW) is a technique
to delay or altogether prevent copying of the data. Rather than duplicate the process
address space, the parent and the child can share a single copy.

The data, however, is marked in such a way that if it is written to, a duplicate is made
and each process receives a unique copy. Consequently, the duplication of resources
occurs only when they are written; until then, they are shared read-only.This technique
delays the copying of each page in the address space until it is actually written to. In the
case that the pages are never written—for example, if exec() is called immediately after
fork() —they never need to be copied.

The only overhead incurred by fork() is the duplication of the parent’s page tables
and the creation of a unique process descriptor for the child. In the common case that a
process executes a new executable image immediately after forking, this optimization pre-
vents the wasted copying of large amounts of data.

$$$The Linux Implementation of Threads
--->Linux has a unique implementation of threads.To the Linux kernel, there is no concept of a thread. 
Linux implements all threads as standard processes.
 The Linux Kernel does not provide any special scheduling semantics or data structures to represent threads.
-->Each thread has a unique task_struct and appears to the kernel as a normal process

-->For example, assume you have a process that consists of four
threads. On systems with explicit thread support, one process descriptor might exist that,
in turn, points to the four different threads.The process descriptor describes the shared
resources, such as an address space or open files.The threads then describe the resources
they alone possess. Conversely, in Linux, there are simply four processes and thus four
normal task_struct structures.The four processes are set up to share certain resources.











