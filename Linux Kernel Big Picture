The operating system is considered the parts of the system
responsible for basic use and administration.This includes the kernel and device drivers,
boot loader, command shell or other user interface, and basic file and system utilities.
The basics of a Linux system are the kernel, C library, toolchain, and basic system utilities, such as a login process and shell.

The user interface is the outer-most portion of the operating system, the kernel is the innermost. It is the core internals;
the software that provides basic services for all other parts of the system, manages hard-
ware, and distributes system resources.The kernel is sometimes referred to as the
supervisor, core, or internals of the operating system.

Typical components of a kernel are interrupt handlers to service interrupt requests, a scheduler to share processor time
among multiple processes, a memory management system to manage process address
spaces, and system services such as networking and interprocess communication.

Modern systems with protected memory management units, the kernel typically resides in
an elevated system state compared to normal user applications.This includes a protected
memory space and full access to the hardware.This system state and memory space is collectively referred to as kernel-space.
Conversely, user applications execute in user-space.

When executing kernel code, the system is in kernel-space executing in kernel mode.When running a regular process, the system is in user-space executing in user mode.

Applications running on the system communicate with the kernel via system calls.
An application typically calls functions in a library—for example, the C
library—that in turn rely on the system call interface to instruct the kernel to carry out
tasks on the application’s behalf. Some library calls provide many features not found in the
system call, and thus, calling into the kernel is just one step in an otherwise large function.

Still other C library functions, such as strcpy() , should (one hopes) make no direct use
of the kernel at all.

When an application executes a system call, we say that the kernel is
executing on behalf of the application. Furthermore, the application is said to be executing a
system call in kernel-space, and the kernel is running in process context.This relationship—
that applications call into the kernel via the system call interface—is the fundamental manner in 
which applications get work done.

The kernel also manages the system’s hardware. Nearly all architectures, including all
systems that Linux supports, provide the concept of interrupts.When hardware wants to
communicate with the system, it issues an interrupt that literally interrupts the processor,
which in turn interrupts the kernel.A number identifies interrupts and the kernel uses
this number to execute a specific interrupt handler to process and respond to the interrupt.
For example, as you type, the keyboard controller issues an interrupt to let the system
know that there is new data in the keyboard buffer.The kernel notes the interrupt num-
ber of the incoming interrupt and executes the correct interrupt handler.The interrupt
handler processes the keyboard data and lets the keyboard controller know it is ready for
more data.


In many operating systems, including Linux,
the interrupt handlers do not run in a process context. Instead, they run in a special
interrupt context that is not associated with any process.This special context exists solely to
let an interrupt handler quickly respond to an interrupt, and then exit.

In fact, in Linux, we can generalize that each processor is doing exactly one of three things at any given moment:

1)In user-space, executing user code in a process
2)In kernel-space, in process context, executing on behalf of a specific process
3)In kernel-space, in interrupt context, not associated with a process, handling an interrupt


Monolithic Kernel Versus Microkernel Designs

##We can divide kernels into two main schools of design: the monolithic kernel and the micro-
kernel. (A third camp, exokernel, is found primarily in research systems.)

-->Monolithic kernels are the simpler design of the two, and all kernels were designed in this
manner until the 1980s. Monolithic kernels are implemented entirely as a single process
running in a single address space. Consequently, such kernels typically exist on disk as sin-
gle static binaries. All kernel services exist and execute in the large kernel address space.
Communication within the kernel is trivial because everything runs in kernel mode in the
same address space: The kernel can invoke functions directly, as a user-space application
might. Proponents of this model cite the simplicity and performance of the monolithic
approach. Most Unix systems are monolithic in design.

-->Microkernels, on the other hand, are not implemented as a single large process. Instead,
the functionality of the kernel is broken down into separate processes, usually called
servers. Ideally, only the servers absolutely requiring such capabilities run in a privileged exe-
cution mode. The rest of the servers run in user-space. All the servers, though, are sepa-
rated into different address spaces. Therefore, direct function invocation as in monolithic
kernels is not possible. Instead, microkernels communicate via message passing: An inter-
process communication (IPC) mechanism is built into the system, and the various servers
communicate with and invoke “services” from each other by sending messages over the IPC
mechanism. The separation of the various servers prevents a failure in one server from
bringing down another. Likewise, the modularity of the system enables one server to be
swapped out for another.

Linux is a monolithic kernel; that is, the Linux kernel executes in a single address space
entirely in kernel mode. Linux, however, borrows much of the good from microkernels: Linux
boasts a modular design, the capability to preempt itself (called kernel preemption), support
for kernel threads, and the capability to dynamically load separate binaries (kernel modules)
into the kernel image. Conversely, Linux has none of the performance-sapping features that
curse microkernel design: Everything runs in kernel mode, with direct function invocation—
not message passing—the modus of communication. Nonetheless, Linux is modular,
threaded, and the kernel itself is schedulable.

A handful of notable differences exist between the Linux kernel and classic
Unix systems:

1)Linux supports the dynamic loading of kernel modules.Although the Linux kernel
is monolithic, it can dynamically load and unload kernel code on demand.

2)Linux has symmetrical multiprocessor (SMP) support.Although most commercial
variants of Unix now support SMP, most traditional Unix implementations did not.

3)The Linux kernel is preemptive. Unlike traditional Unix variants, the Linux kernel
can preempt a task even as it executes in the kernel. Of the other commercial Unix
implementations, Solaris and IRIX have preemptive kernels, but most Unix kernels
are not preemptive.

4)Linux takes an interesting approach to thread support: It does not differentiate
between threads and normal processes.To the kernel, all processes are the same—
some just happen to share resources.

5)Linux provides an object-oriented device model with device classes, hot-pluggable
events, and a user-space device filesystem (sysfs).
Linux ignores some common Unix features that the kernel developers consider
poorly designed, such as STREAMS, or standards that are impossible to cleanly
implement.

6)Linux is free in every sense of the word.The feature set Linux implements is the
result of the freedom of Linux’s open development model. If a feature is without
merit or poorly thought out, Linux developers are under no obligation to imple-
ment it.To the contrary, Linux has adopted an elitist attitude toward changes: Mod-
ifications must solve a specific real-world problem, derive from a clean design, and
have a solid implementation. Consequently, features of some other modern Unix
variants that are more marketing bullet or one-off requests, such as pageable kernel
memory, have received no consideration.

This are the limitation/issues with kernel:

1)The kernel has access to neither the C library nor the standard C headers.
2)The kernel is coded in GNU C.
3)The kernel lacks the memory protection afforded to user-space.
4)The kernel cannot easily execute floating-point operations.
5)The kernel has a small per-process fixed-size stack.
6)Because the kernel has asynchronous interrupts, is preemptive, and supports SMP,
synchronization and concurrency are major concerns within the kernel.
Portability is important.

1-->
The full C library—or even a decent subset of it—is too large and too inefficient for the kernel.
Many of the usual libc functions are implemented inside the kernel. For
example, the common string manipulation functions are in lib/string.c . Just include
the header file <linux/string.h> and have at them.

When I talk about header files in this book, I am referring to the kernel header files that are
part of the kernel source tree. Kernel source files cannot include outside headers, just as
they cannot use outside libraries.

The base files are located in the include/ directory in the root of the kernel source tree. For
example, the header file <linux/inotify.h> is located at include/linux/inotify.h in
the kernel source tree.

A set of architecture-specific header files are located in arch/<architecture>/include/asm
in the kernel source tree. For example, if compiling for the x86 architecture, your architec-
ture-specific headers are in arch/x86/include/asm . Source code includes these headers
via just the asm/ prefix, for example <asm/ioctl.h> .

The kernel does not have access to printf() , but it does provide printk() , which works pretty much the same as
its more familiar cousin.The printk() function copies the formatted string into the kernel log buffer, 
which is normally read by the syslog program.

One notable difference between printf() and printk() is that printk() enables you
to specify a priority flag.This flag is used by syslogd to decide where to display kernel
messages. Here is an example of these priorities:

-->printk(KERN_ERR "this is an error!\n");

Note there is no comma between KERN_ERR and the printed message.This is intentional; 
the priority flag is a preprocessor-define representing a string literal, which is con-
catenated onto the printed message during compilation.

Perhaps surprisingly, the kernel is not programmed in strict ANSI C.Instead, where applicable, the
kernel developers make use of various language extensions available in gcc (the GNU
Compiler Collection, which contains the C compiler used to compile the kernel and
most everything else written in C on a Linux system).

The gcc C compiler enables the embedding of assembly instructions in otherwise normal
C functions.This feature, of course, is used in only those parts of the kernel that are
unique to a given system architecture.



###Inline Assembly
-->an inline assembler is a feature of some compilers that allows low-level code written in assembly language to be embedded within a program, among code that otherwise has been compiled from a higher-level language such as C or Ada. 
The asm() compiler directive is used to inline assembly code. For example, this inline
assembly directive executes the x86 processor’s rdtsc instruction, which returns the value
of the timestamp ( tsc ) register:
unsigned int low, high;

The embedding of assembly language code is usually done for one of three reasons:

1)Optimization: Programmers can use assembly language code to implement the most performance-sensitive parts of their program's algorithms, code that is apt to be more efficient than what might otherwise be generated by the compiler.

2)Access to processor specific instructions: Most processors offer special instructions, such as Compare and Swap and Test and Set instructions which may be used to construct semaphores or other synchronization and locking primitives. Nearly every modern processor has these or similar instructions, as they are necessary to implement multitasking. Examples of specialized instructions are found in the SPARC VIS, Intel MMX and SSE, and Motorola Altivec instruction sets.

3)System calls: High-level languages rarely have a direct facility to make arbitrary system calls, so assembly code is used. 

 Lets understand each of them in detail:
 
1) System call:
Calling an operating system directly is generally not possible under a system using protected memory. The OS runs at a more privileged level (kernel mode) than the user (user mode); a (software) interrupt is used to make requests to the operating system. This is rarely a feature in a higher-level language, and so wrapper functions for system calls are written using inline assembler. 

A wrapper function is a subroutine in a software library or a computer program whose main purpose is to call a second subroutine[1] or a system call with little or no additional computation. Wrapper functions are used to make writing computer programs easier by abstracting away the details of a subroutine's underlying implementation. 

The following C code example shows a system call wrapper in AT&T assembler syntax, using the GNU Assembler. Such calls are normally written with the aid of macros; the full code is included for clarity.

The format of basic inline assembly is very straightforward:

asm (<assembly code>);

Example: Refer https://en.wikipedia.org/wiki/Inline_assembler for more detail

What is asm?
-->The asm keyword allows you to embed assembler instructions within C code. GCC provides two forms of inline asm statements. A basic asm statement is one with no operands (see Basic Asm), while an extended asm statement (see Extended Asm) includes one or more operands. The extended form is preferred for mixing C and assembly language within a function, but to include assembly language at top level you must use basic asm. 

Which assembly instructin set is used now a days ?
-->x86 is a family of instruction set architectures which was developed in 1972 and still used.It is the collobration
of intel and AMD which supports lots of processors.


The Linux kernel is written in a mixture of C and assembly, with assembly relegated
to low-level architecture and fast path code.The vast majority of kernel code is pro-
grammed in straight C

When compiling an assembly statement on Linux*, the compiler simply emits the asm-template to the assembly file after making any necessary operand substitutions. The compiler then calls the GNU* assembler to generate machine code. In contrast, on Windows* the compiler itself must assemble the text contained in the asm-template string into machine code. In essence, the compiler contains a built-in assembler. 

The GNU Assembler, commonly known as gas or simply as, its executable name, is the assembler used by the GNU Project. It is the default back-end of GCC. 

-->kernel memory is not pageable.Therefore, every byte of memory you
consume is one less byte of available physical memory. Keep that in mind the next time
you need to add one more feature to the kernel!



$$$Process and Threads
--->Linux has a unique implementation of threads: It does not differentiate between
threads and processes.To Linux, a thread is just a special kind of process.

--->On modern operating systems, processes provide two virtualizations: a virtualized
processor and virtual memory.The virtual processor gives the process the illusion that it
alone monopolizes the system, despite possibly sharing the processor among hundreds of
other processes.

--->In contemporary Linux kernels, fork() is actually implemented via the clone() sys-
tem call

--->Finally, a program exits via the exit() system call.This function terminates the process
and frees all its resources.A parent process can inquire about the status of a terminated
child via the wait4() 1 system call, which enables a process to wait for the termination of
a specific process.When a process exits, it is placed into a special zombie state that repre-
sents terminated processes until the parent calls wait() or waitpid() .

Another name for a process is a task.

$$$Process Descriptor and the Task Structure
-->The kernel stores the list of processes in a circular doubly linked list called the task list. 2
Each element in the task list is a process descriptor of the type struct task_struct , which
is defined in <linux/sched.h> .The process descriptor contains all the information about
a specific process.

The task_struct is a relatively large data structure, at around 1.7 kilobytes on a 32-bit
machine.This size, however, is quite small considering that the structure contains all the
information that the kernel has and needs about a process.

--> struct task_struct{               //Process Control Block
struct thread_info;
...
....
Total 1kb 
}
-->struct thread_info {
....
}



Inside the kernel, tasks are typically referenced directly by a pointer to their
task_struct structure. In fact, most kernel code that deals with processes works directly
with struct task_struct . Consequently, it is useful to be able to quickly look up the
process descriptor of the currently executing task, which is done via the current macro.

$$$process state
Each process on the system is in exactly one of five different states.This
value is represented by one of five flags:

1)TASK_RUNNING —The process is runnable; it is either currently running or on a run-
queue waiting to run (runqueues are discussed in Chapter 4).This is the only possi-
ble state for a process executing in user-space; it can also apply to a process in
kernel-space that is actively running.

2)TASK_INTERRUPTIBLE —The process is sleeping (that is, it is blocked), waiting for
some condition to exist.When this condition exists, the kernel sets the process’s
state to TASK_RUNNING .The process also awakes prematurely and becomes runnable
if it receives a signal.


3)TASK_UNINTERRUPTIBLE —This state is identical to TASK_INTERRUPTIBLE except
that it does not wake up and become runnable if it receives a signal.This is used in
situations where the process must wait without interruption or when the event is
expected to occur quite quickly. Because the task does not respond to signals in
this state, TASK_UNINTERRUPTIBLE is less often used than TASK_INTERRUPTIBLE

4)__TASK_TRACED —The process is being traced by another process, such as a debug-
ger, via ptrace.

5)__TASK_STOPPED —Process execution has stopped; the task is not running nor is it
eligible to run.This occurs if the task receives the SIGSTOP , SIGTSTP , SIGTTIN , or
SIGTTOU signal or if it receives any signal while it is being debugged.

Kernel code often needs to change a process’s state.The preferred mechanism is using
set_task_state(task, state);
/* set task ‘task’ to state ‘state’ */
This function sets the given task to the given state. If applicable, it also provides a
memory barrier to force ordering on other processors. (This is only needed on SMP sys-
tems.) Otherwise, it is equivalent to
task->state = state;

System calls and exception handlers are well-defined interfaces into the kernel.A
process can begin executing in kernel-space only through one of these interfaces—all
access to the kernel is through these interfaces.

$$$Process Family Tree
--->All processes are descendants of the init process, whose PID is one.The kernel starts
init in the last step of the boot process.The init process, in turn, reads the system
initscripts and executes more programs, eventually completing the boot process.

Consequently, give the current process, it is possible to obtain the process
descriptor of its parent with the following code:

/* struct task_struct *my_parent = current->parent;   */

In fact, you can follow the process hierarchy from any one process in the system to any
other. Oftentimes, however, it is desirable simply to iterate over all processes in the system.
This is easy because the task list is a circular, doubly linked list.

$$$Copy-on-Write
Traditionally, upon fork(), all resources owned by the parent are duplicated and the
copy is given to the child.This approach is naive and inefficient in that it copies much
data that might otherwise be shared.Worse still, if the new process were to immediately
execute a new image, all that copying would go to waste. In Linux, fork() is imple-
mented through the use of copy-on-write pages. Copy-on-write (or COW) is a technique
to delay or altogether prevent copying of the data. Rather than duplicate the process
address space, the parent and the child can share a single copy.

The data, however, is marked in such a way that if it is written to, a duplicate is made
and each process receives a unique copy. Consequently, the duplication of resources
occurs only when they are written; until then, they are shared read-only.This technique
delays the copying of each page in the address space until it is actually written to. In the
case that the pages are never written—for example, if exec() is called immediately after
fork() —they never need to be copied.

The only overhead incurred by fork() is the duplication of the parent’s page tables
and the creation of a unique process descriptor for the child. In the common case that a
process executes a new executable image immediately after forking, this optimization pre-
vents the wasted copying of large amounts of data.

$$$The Linux Implementation of Threads
--->Linux has a unique implementation of threads.To the Linux kernel, there is no concept of a thread. 
Linux implements all threads as standard processes.
 The Linux Kernel does not provide any special scheduling semantics or data structures to represent threads.
-->Each thread has a unique task_struct and appears to the kernel as a normal process

-->For example, assume you have a process that consists of four
threads. On systems with explicit thread support, one process descriptor might exist that,
in turn, points to the four different threads.The process descriptor describes the shared
resources, such as an address space or open files.The threads then describe the resources
they alone possess. Conversely, in Linux, there are simply four processes and thus four
normal task_struct structures.The four processes are set up to share certain resources.

$$Kernel Threads:This thread is created by the kernel itself

Dont confuse yourself with user level thread which is also kernel level thread but those are created by the user process.

-->It is often useful for the kernel to perform some operations in the background.The ker-
nel accomplishes this via kernel threads—standard processes that exist solely in kernel-
space.The significant difference between kernel threads and normal processes is that
kernel threads do not have an address space. (Their mm pointer, which points at their
address space, is NULL .) They operate only in kernel-space and do not context switch into
user-space. Kernel threads, however, are schedulable and preemptable, the same as normal
processes.
-->Linux delegates several tasks to kernel threads, most notably the flush tasks and the
ksoftirqd task.You can see the kernel threads on your Linux system by running the com-
mand ps -ef .There are a lot of them! Kernel threads are created on system boot by
other kernel threads. Indeed, a kernel thread can be created only by another kernel
thread.

-->Similar to pthread_create using which user level process creates thread... there is kthread_create using 
which kernel creates thread.

$$Kernel threads vs User Threads

-->User threads and Kernel threads are exactly the same. (You can see by looking in /proc/ and see that the kernel threads are there too.)

-->A User thread is one that executes user-space code. But it can call into kernel space at any time. It's still considered a "User" thread, even though it's executing kernel code at elevated security levels.

-->A Kernel thread is one that only runs kernel code and isn't associated with a user-space process. These are like "UNIX daemons", except they are kernel-only daemons. So you could say that the kernel is a multi-threaded program. For example, there is a kernel thread for swap. This forces all swap issues to get "serialized" into a single stream.

-->If a user thread needs something, it will call into the kernel, which marks that thread as sleeping. Later, the swap thread finds the data, so it marks the user thread as runnable. Later still, the "user thread" returns from the kernel back to userland as if nothing happened.

-->In fact, all threads start off in kernel space, because the clone() operation happens in kernel space. (And there's lots of kernel accounting to do before you can 'return' to a new process in user space.)

$$Process Termination

-->When a process terminates, the kernel releases
the resources owned by the process and notifies the child’s parent of its demise.
-->Generally, process destruction is self-induced. It occurs when the process calls the
exit() system call, either explicitly when it is ready to terminate or implicitly on return
from the main subroutine of any program. (That is, the C compiler places a call to exit()
after main() returns.) A process can also terminate involuntarily.This occurs when process receives a signal or exception it cannot handle or ignore. Regardless of how a process terminates, the bulk of the work is handled by do_exit() , defined in kernel/exit.c , which completes a number of chores:


-----------------------------------------------------------------------------------------------------
$$$ System Calls
-->
In any modern operating system, the kernel provides a set of interfaces by which
running in user-space can interact with the system.These interfaces give appli-
cations controlled access to hardware, a mechanism with which to create new processes
and communicate with existing ones, and the capability to request other operating system
resources.The interfaces act as the messengers between applications and the kernel, with
the applications issuing various requests and the kernel fulfilling them (or returning an
error).The existence of these interfaces, and the fact that applications are not free to
directly do whatever they want, is key to providing a stable system.


###Communicating with the Kernel
-->System calls provide a layer between the hardware and user-space processes.This layer
serves three primary purposes.

1)First, it provides an abstracted hardware interface for user-
space.When reading or writing from a file, for example, applications are not concerned
with the type of disk, media, or even the type of filesystem on which the file resides.

2)Second, system calls ensure system security and stability.With the kernel acting as a middle-
man between system resources and user-space, the kernel can arbitrate access based on
permissions, users, and other criteria.For example, this arbitration prevents applications
from incorrectly using hardware, stealing other processes’ resources, or otherwise doing
harm to the system.

3)In Linux, system calls are the only means user-space has of interfacing with the kernel; they are the only
legal entry point into the kernel other than exceptions and traps.


###APIs, POSIX, and the C Library

-->Typically, applications are programmed against an Application Programming Interface
(API) implemented in user-space, not directly to system calls.This is important because
no direct correlation is needed between the interfaces that applications make use of and
the actual interface provided by the kernel.An API defines a set of programming inter-
faces used by applications.Those interfaces can be implemented as a system call, imple-
mented through multiple system calls, or implemented without the use of system calls at
all.The same API can exist on multiple systems and provide the same interface to applica-
tions while the implementation of the API itself can differ greatly from system to system.

-->One of the more common application programming interfaces in the Unix world is
based on the POSIX standard.
-->POSIX is an excellent example of the relationship between APIs and system calls. On
most Unix systems, the POSIX-defined API calls have a strong correlation to the system
calls.

-------->There are about 335 system calls are on x86. (Each architecture is allowed to define unique system
calls.) Although not all operating systems publish their exact system calls, some operating systems are
estimated to have more than one thousand. In the previous edition of this book, x86 had only 250 sys-
tem calls.

How system calls are implemented?
-->A single system call invocation in assembler language is usually multiple lines of code. First the parameters for the system call are loaded in appropriate processor registers and/or to the stack, and then a special instruction like int 0x80 or syscall is used to actually make the system call.

--> On Unix-like systems, that API is usually part of an implementation of the C library (libc), such as glibc, that provides wrapper functions for the system calls, often named the same as the system calls they invoke. 

--> The library's wrapper functions expose an ordinary function calling convention (a subroutine call on the assembly level) for using the system call, as well as making the system call more modular. Here, the primary function of the wrapper is to place all the arguments to be passed to the system call in the appropriate processor registers (and maybe on the call stack as well), and also setting a unique system call number for the kernel to call. In this way the library, which exists between the OS and the application, increases portability. 

--> call to the library function itself does not cause a switch to kernel mode (if the execution was not already in kernel mode) and is usually a normal subroutine call (using, for example, a "CALL" assembly instruction in some Instruction set architectures (ISAs)). The actual system call does transfer control to the kernel (and is more implementation-dependent and platform-dependent than the library call abstracting it). For example, in Unix-like systems, fork and execve are C library functions that in turn execute instructions that invoke the fork and exec system calls.

-->Making the system call directly in the application code is more complicated and may require embedded assembly code to be used (in C and C++) as well as knowledge of the low-level binary interface for the system call operation, which may be subject to change over time and thus not be part of the application binary interface; the library functions are meant to abstract this away. 

-->Implementing system calls requires a transfer of control from user space to kernel space, which involves some sort of architecture-specific feature. A typical way to implement this is to use a software interrupt or trap. Interrupts transfer control to the operating system kernel, so software simply needs to set up some register with the system call number needed, and execute the software interrupt. 

-->The C library additionally provides the majority of the POSIX API.


--->The system call interface in Linux, as with most Unix systems, is provided in part by
the C library.The C library implements the main API on Unix systems, including the
standard C library and the system call interface.The C library is used by all C programs
and, because of C’s nature, is easily wrapped by other programming languages for use in
their programs.The C library additionally provides the majority of the POSIX API.


-->From the application programmer’s point of view, system calls are irrelevant; all the
programmer is concerned with is the API. Conversely, the kernel is concerned only with
the system calls; what library calls and applications make use of the system calls is not of
the kernel’s concern. Nonetheless, it is important for the kernel to keep track of the
potential uses of a system call and keep the system call as general and flexible as possible.
A meme related to interfaces in Unix is “Provide mechanism, not policy.” In other
words, Unix system calls exist to provide a specific function in an abstract sense.The
manner in which the function is used is not any of the kernel’s business.


###Syscalls

-->System calls (often called syscalls in Linux) are typically accessed via function calls defined
in the C library.They can define zero, one, or more arguments (inputs) and might result
in one or more side effects, 3 for example writing to a file or copying some data into a
provided pointer. System calls also provide a return value of type long 4 that signifies suc-
cess or error—usually, although not always, a negative return value denotes an error.A
return value of zero is usually (but again not always) a sign of success.The C library, when
a system call returns an error, writes a special error code into the global errno variable.
This variable can be translated into human-readable errors via library functions such as
perror() .

-->Finally, system calls have a defined behavior. For example, the system call getpid() is
defined to return an integer that is the current process’s PID.The implementation of this
syscall in the kernel is simple:

SYSCALL_DEFINE0(getpid)
{
return task_tgid_vnr(current); // returns current->tgid
}

-->the getpid() system call is defined as sys_getpid() in the kernel.This is the naming con-
vention taken with all system calls in Linux: System call bar() is implemented in the ker-
nel as function sys_bar() .

###System Call Numbers
-->In Linux, each system call is assigned a syscall number.This is a unique number that is used
to reference a specific system call.When a user-space process executes a system call, the
syscall number identifies which syscall was executed; the process does not refer to the
syscall by name

-->The syscall number is important; when assigned, it cannot change, or compiled appli-
cations will break. Likewise, if a system call is removed, its system call number cannot be
recycled, or previously compiled code would aim to invoke one system call but would in
reality invoke another.

-->The kernel keeps a list of all registered system calls in the system call table, stored in
sys_call_table .This table is architecture; on x86-64 it is defined in
arch/i386/kernel/syscall_64.c .This table assigns each valid syscall to a unique
syscall number.


###System Call Handler

-->It is not possible for user-space applications to execute kernel code directly.They cannot
simply make a function call to a method existing in kernel-space because the kernel exists
in a protected memory space. If applications could directly read and write to the kernel’s
address space, system security and stability would be nonexistent.

-->Instead, user-space applications must somehow signal to the kernel that they want to
execute a system call and have the system switch to kernel mode, where the system call
can be executed in kernel-space by the kernel on behalf of the application.

-->Instead, user-space applications must somehow signal to the kernel that they want to
execute a system call and have the system switch to kernel mode, where the system call
can be executed in kernel-space by the kernel on behalf of the application.
The mechanism to signal the kernel is a software interrupt: Incur an exception, and
the system will switch to kernel mode and execute the exception handler.The exception
handler, in this case, is actually the system call handler.The defined software interrupt on
x86 is interrupt number 128, which is incurred via the int $0x80 instruction. It triggers
a switch to kernel mode and the execution of exception vector 128, which is the system
call handler.The system call handler is the aptly named function system_call() . It is
architecture-dependent; on x86-64 it is implemented in assembly in entry_64.S . 6
Recently, x86 processors added a feature known as sysenter.This feature provides a faster,
more specialized way of trapping into a kernel to execute a system call than using the int
interrupt instruction. Support for this feature was quickly added to the kernel. Regardless
of how the system call handler is invoked, however, the important notion is that somehow
user-space causes an exception or trap to enter the kernel.



##Denoting the Correct System Call

--->Simply entering kernel-space alone is not sufficient because multiple system calls exist, all
of which enter the kernel in the same manner.Thus, the system call number must be
passed into the kernel. On x86, the syscall number is fed to the kernel via the eax regis-
ter. Before causing the trap into the kernel, user-space sticks in eax the number corre-
sponding to the desired system call.The system call handler then reads the value from
eax . Other architectures do something similar.

-->The system_call() function checks the validity of the given system call number by
comparing it to NR_syscalls . If it is larger than or equal to NR_syscalls , the function
returns -ENOSYS . Otherwise, the specified system call is invoked:
call *sys_call_table(,%rax,8)

--->Because each element in the system call table is 64 bits (8 bytes), the kernel multiplies
the given system call number by four to arrive at its location in the system call table. On
x86-32, the code is similar, with the 8 replaced by 4

-->Refer to Invoking the system call handler and executing a system call.gif

###Parameter Passing
-->In addition to the system call number, most syscalls require that one or more parameters
be passed to them. Somehow, user-space must relay the parameters to the kernel during
the trap.The easiest way to do this is via the same means that the syscall number is passed:
The parameters are stored in registers. On x86-32, the registers ebx , ecx , edx , esi , and
edi contain, in order, the first five arguments. In the unlikely case of six or more argu-
ments, a single register is used to hold a pointer to user-space where all the parameters
are stored.The return value is sent to user-space also via register. On x86, it is written into the
eax register

###System Call Implementation

-->Let’s look at the steps involved in writing a new system call for Linux:

--->The first step in implementing a system call is defining its purpose.What will it do? The
syscall should have exactly one purpose. Multiplexing syscalls (a single system call that
does wildly different things depending on a flag argument) is discouraged in Linux. Look
at ioctl() as an example of what not to do.

-->What are the new system call’s arguments, return value, and error codes? The system
call should have a clean and simple interface with the smallest number of arguments possi-
ble.The semantics and behavior of a system call are important; they must not change,
because existing applications will come to rely on them.
-------------------------------------------------------------------------------------------------------------------
Chapter:Interrupt

-->The function the kernel runs in response to a specific interrupt is called an interrupt handler
or interrupt service routine (ISR). Each device that generates interrupts has an associated
interrupt handler. For example, one function handles interrupts from the system timer,
whereas another function handles interrupts generated by the keyboard.The interrupt
handler for a device is part of the device’s driver—the kernel code that manages the device.

-->In Linux, interrupt handlers are normal C functions.They match a specific prototype,
which enables the kernel to pass the handler information in a standard way, but otherwise they are ordinary functions.

-->What differentiates interrupt handlers from other kernel func-
tions is that the kernel invokes them in response to interrupts and that they run in a spe-
cial context (discussed later in this chapter) called interrupt context.This special context is
occasionally called atomic context because, as we shall see, code executing in this context is
unable to block. In this book, we will use the term interrupt context.

#####Top Halves Versus Bottom Halves
-->These two goals—that an interrupt handler execute quickly and perform a large amount
of work—clearly conflict with one another. Because of these competing goals, the pro-
cessing of interrupts is split into two parts, or halves.The interrupt handler is the top half.
The top half is run immediately upon receipt of the interrupt and performs only the
work that is time-critical, such as acknowledging receipt of the interrupt or resetting the
hardware.Work that can be performed later is deferred until the bottom half.The bottom
half runs in the future, at a more convenient time, with all interrupts enabled.

--->Let’s look at an example of the top-half/bottom-half dichotomy, using our old friend,
the network card.When network cards receive packets from the network, they need to
alert the kernel of their availability.They want and need to do this immediately, to opti-
mize network throughput and latency and avoid timeouts.Thus, they immediately issue an
interrupt: Hey, kernel, I have some fresh packets here! The kernel responds by executing the
network card’s registered interrupt.
The interrupt runs, acknowledges the hardware, copies the new networking packets
into main memory, and readies the network card for more packets.These jobs are the
important, time-critical, and hardware-specific work.The kernel generally needs to
quickly copy the networking packet into main memory because the network data buffer
on the networking card is fixed and miniscule in size, particularly compared to main
memory. Delays in copying the packets can result in a buffer overrun, with incoming
packets overwhelming the networking card’s buffer and thus packets being dropped.After
the networking data is safely in the main memory, the interrupt’s job is done, and it canreturn control of the system to whatever code was interrupted when the interrupt was
generated.The rest of the processing and handling of the packets occurs later, in the bot-
tom half.

##Reentrancy and Interrupt Handlers
Interrupt handlers in Linux need not be reentrant. When a given interrupt handler is execut-
ing, the corresponding interrupt line is masked out on all processors, preventing another
interrupt on the same line from being received. Normally all other interrupts are enabled, so
other interrupts are serviced, but the current line is always disabled. Consequently, the
same interrupt handler is never invoked concurrently to service a nested interrupt. This
greatly simplifies writing your interrupt handler.


##Interrupt Context

-->When executing an interrupt handler, the kernel is in interrupt context. Recall that process
context is the mode of operation the kernel is in while it is executing on behalf of a
process—for example, executing a system call or running a kernel thread. In process con-
text, the current macro points to the associated task. Furthermore, because a process is
coupled to the kernel in process context, process context can sleep or otherwise invoke
the scheduler.

-->Interrupt context, on the other hand, is not associated with a process.The current
macro is not relevant (although it points to the interrupted process).Without a backing
process, interrupt context cannot sleep—how would it ever reschedule? Therefore, you
cannot call certain functions from interrupt context. If a function sleeps, you cannot use it
from your interrupt handler—this limits the functions that one can call from an interrupt
handler.
-->Interrupt context is time-critical because the interrupt handler interrupts other code.
Code should be quick and simple. Busy looping is possible, but discouraged.This is an
important point; always keep in mind that your interrupt handler has interrupted other
code (possibly even another interrupt handler on a different line!). Because of this asyn-
chronous nature, it is imperative that all interrupt handlers be as quick and as simple as
possible.As much as possible, work should be pushed out from the interrupt handler and
performed in a bottom half, which runs at a more convenient time.

-->When interrupt is first generated by  it doesnt directly goes to the processor but it first goes to the hardware knows as
interrupt controller.

-->In computing, a programmable interrupt controller (PIC) is a device that is used to combine several sources of interrupt onto one or more CPU lines, while allowing priority levels to be assigned to its interrupt outputs. When the device has multiple interrupt outputs to assert, it asserts them in the order of their relative priority.




