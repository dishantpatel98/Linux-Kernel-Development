The operating system is considered the parts of the system
responsible for basic use and administration.This includes the kernel and device drivers,
boot loader, command shell or other user interface, and basic file and system utilities.
The basics of a Linux system are the kernel, C library, toolchain, and basic system utilities, such as a login process and shell.

The user interface is the outer-most portion of the operating system, the kernel is the innermost. It is the core internals;
the software that provides basic services for all other parts of the system, manages hard-
ware, and distributes system resources.The kernel is sometimes referred to as the
supervisor, core, or internals of the operating system.

Typical components of a kernel are interrupt handlers to service interrupt requests, a scheduler to share processor time
among multiple processes, a memory management system to manage process address
spaces, and system services such as networking and interprocess communication.

Modern systems with protected memory management units, the kernel typically resides in
an elevated system state compared to normal user applications.This includes a protected
memory space and full access to the hardware.This system state and memory space is collectively referred to as kernel-space.
Conversely, user applications execute in user-space.

When executing kernel code, the system is in kernel-space executing in kernel mode.When running a regular process, the system is in user-space executing in user mode.

Applications running on the system communicate with the kernel via system calls.
An application typically calls functions in a library—for example, the C
library—that in turn rely on the system call interface to instruct the kernel to carry out
tasks on the application’s behalf. Some library calls provide many features not found in the
system call, and thus, calling into the kernel is just one step in an otherwise large function.

Still other C library functions, such as strcpy() , should (one hopes) make no direct use
of the kernel at all.

When an application executes a system call, we say that the kernel is
executing on behalf of the application. Furthermore, the application is said to be executing a
system call in kernel-space, and the kernel is running in process context.This relationship—
that applications call into the kernel via the system call interface—is the fundamental manner in 
which applications get work done.

The kernel also manages the system’s hardware. Nearly all architectures, including all
systems that Linux supports, provide the concept of interrupts.When hardware wants to
communicate with the system, it issues an interrupt that literally interrupts the processor,
which in turn interrupts the kernel.A number identifies interrupts and the kernel uses
this number to execute a specific interrupt handler to process and respond to the interrupt.
For example, as you type, the keyboard controller issues an interrupt to let the system
know that there is new data in the keyboard buffer.The kernel notes the interrupt num-
ber of the incoming interrupt and executes the correct interrupt handler.The interrupt
handler processes the keyboard data and lets the keyboard controller know it is ready for
more data.


In many operating systems, including Linux,
the interrupt handlers do not run in a process context. Instead, they run in a special
interrupt context that is not associated with any process.This special context exists solely to
let an interrupt handler quickly respond to an interrupt, and then exit.

In fact, in Linux, we can generalize that each processor is doing exactly one of three things at any given moment:

1)In user-space, executing user code in a process
2)In kernel-space, in process context, executing on behalf of a specific process
3)In kernel-space, in interrupt context, not associated with a process, handling an interrupt


Monolithic Kernel Versus Microkernel Designs

##We can divide kernels into two main schools of design: the monolithic kernel and the micro-
kernel. (A third camp, exokernel, is found primarily in research systems.)

-->Monolithic kernels are the simpler design of the two, and all kernels were designed in this
manner until the 1980s. Monolithic kernels are implemented entirely as a single process
running in a single address space. Consequently, such kernels typically exist on disk as sin-
gle static binaries. All kernel services exist and execute in the large kernel address space.
Communication within the kernel is trivial because everything runs in kernel mode in the
same address space: The kernel can invoke functions directly, as a user-space application
might. Proponents of this model cite the simplicity and performance of the monolithic
approach. Most Unix systems are monolithic in design.

-->Microkernels, on the other hand, are not implemented as a single large process. Instead,
the functionality of the kernel is broken down into separate processes, usually called
servers. Ideally, only the servers absolutely requiring such capabilities run in a privileged exe-
cution mode. The rest of the servers run in user-space. All the servers, though, are sepa-
rated into different address spaces. Therefore, direct function invocation as in monolithic
kernels is not possible. Instead, microkernels communicate via message passing: An inter-
process communication (IPC) mechanism is built into the system, and the various servers
communicate with and invoke “services” from each other by sending messages over the IPC
mechanism. The separation of the various servers prevents a failure in one server from
bringing down another. Likewise, the modularity of the system enables one server to be
swapped out for another.

Linux is a monolithic kernel; that is, the Linux kernel executes in a single address space
entirely in kernel mode. Linux, however, borrows much of the good from microkernels: Linux
boasts a modular design, the capability to preempt itself (called kernel preemption), support
for kernel threads, and the capability to dynamically load separate binaries (kernel modules)
into the kernel image. Conversely, Linux has none of the performance-sapping features that
curse microkernel design: Everything runs in kernel mode, with direct function invocation—
not message passing—the modus of communication. Nonetheless, Linux is modular,
threaded, and the kernel itself is schedulable.

A handful of notable differences exist between the Linux kernel and classic
Unix systems:

1)Linux supports the dynamic loading of kernel modules.Although the Linux kernel
is monolithic, it can dynamically load and unload kernel code on demand.

2)Linux has symmetrical multiprocessor (SMP) support.Although most commercial
variants of Unix now support SMP, most traditional Unix implementations did not.

3)The Linux kernel is preemptive. Unlike traditional Unix variants, the Linux kernel
can preempt a task even as it executes in the kernel. Of the other commercial Unix
implementations, Solaris and IRIX have preemptive kernels, but most Unix kernels
are not preemptive.

4)Linux takes an interesting approach to thread support: It does not differentiate
between threads and normal processes.To the kernel, all processes are the same—
some just happen to share resources.

5)Linux provides an object-oriented device model with device classes, hot-pluggable
events, and a user-space device filesystem (sysfs).
Linux ignores some common Unix features that the kernel developers consider
poorly designed, such as STREAMS, or standards that are impossible to cleanly
implement.

6)Linux is free in every sense of the word.The feature set Linux implements is the
result of the freedom of Linux’s open development model. If a feature is without
merit or poorly thought out, Linux developers are under no obligation to imple-
ment it.To the contrary, Linux has adopted an elitist attitude toward changes: Mod-
ifications must solve a specific real-world problem, derive from a clean design, and
have a solid implementation. Consequently, features of some other modern Unix
variants that are more marketing bullet or one-off requests, such as pageable kernel
memory, have received no consideration.

This are the limitation/issues with kernel:

1)The kernel has access to neither the C library nor the standard C headers.
2)The kernel is coded in GNU C.
3)The kernel lacks the memory protection afforded to user-space.
4)The kernel cannot easily execute floating-point operations.
5)The kernel has a small per-process fixed-size stack.
6)Because the kernel has asynchronous interrupts, is preemptive, and supports SMP,
synchronization and concurrency are major concerns within the kernel.
Portability is important.

1-->
The full C library—or even a decent subset of it—is too large and too inefficient for the kernel.
Many of the usual libc functions are implemented inside the kernel. For
example, the common string manipulation functions are in lib/string.c . Just include
the header file <linux/string.h> and have at them.

When I talk about header files in this book, I am referring to the kernel header files that are
part of the kernel source tree. Kernel source files cannot include outside headers, just as
they cannot use outside libraries.

The base files are located in the include/ directory in the root of the kernel source tree. For
example, the header file <linux/inotify.h> is located at include/linux/inotify.h in
the kernel source tree.

A set of architecture-specific header files are located in arch/<architecture>/include/asm
in the kernel source tree. For example, if compiling for the x86 architecture, your architec-
ture-specific headers are in arch/x86/include/asm . Source code includes these headers
via just the asm/ prefix, for example <asm/ioctl.h> .

The kernel does not have access to printf() , but it does provide printk() , which works pretty much the same as
its more familiar cousin.The printk() function copies the formatted string into the kernel log buffer, 
which is normally read by the syslog program.

One notable difference between printf() and printk() is that printk() enables you
to specify a priority flag.This flag is used by syslogd to decide where to display kernel
messages. Here is an example of these priorities:

-->printk(KERN_ERR "this is an error!\n");

Note there is no comma between KERN_ERR and the printed message.This is intentional; 
the priority flag is a preprocessor-define representing a string literal, which is con-
catenated onto the printed message during compilation.

Perhaps surprisingly, the kernel is not programmed in strict ANSI C.Instead, where applicable, the
kernel developers make use of various language extensions available in gcc (the GNU
Compiler Collection, which contains the C compiler used to compile the kernel and
most everything else written in C on a Linux system).

The gcc C compiler enables the embedding of assembly instructions in otherwise normal
C functions.This feature, of course, is used in only those parts of the kernel that are
unique to a given system architecture.

###Inline Assembly
-->an inline assembler is a feature of some compilers that allows low-level code written in assembly language to be embedded within a program, among code that otherwise has been compiled from a higher-level language such as C or Ada. 
The asm() compiler directive is used to inline assembly code. For example, this inline
assembly directive executes the x86 processor’s rdtsc instruction, which returns the value
of the timestamp ( tsc ) register:
unsigned int low, high;

The embedding of assembly language code is usually done for one of three reasons:




Optimization: Programmers can use assembly language code to implement the most performance-sensitive parts of their program's algorithms, code that is apt to be more efficient than what might otherwise be generated by the compiler.

Access to processor specific instructions: Most processors offer special instructions, such as Compare and Swap and Test and Set instructions which may be used to construct semaphores or other synchronization and locking primitives. Nearly every modern processor has these or similar instructions, as they are necessary to implement multitasking. Examples of specialized instructions are found in the SPARC VIS, Intel MMX and SSE, and Motorola Altivec instruction sets.

System calls: High-level languages rarely have a direct facility to make arbitrary system calls, so assembly code is used. 

 ISO C standards (annex J) specify a conditionally supported syntax for inline assembler:

        An asm declaration has the form
        asm-definition:
        asm ( string-literal ) ;
        The asm declaration is conditionally-supported; its meaning is implementation-defined.
##Example of system call:
Calling an operating system directly is generally not possible under a system using protected memory. The OS runs at a more privileged level (kernel mode) than the user (user mode); a (software) interrupt is used to make requests to the operating system. This is rarely a feature in a higher-level language, and so wrapper functions for system calls are written using inline assembler. 

A wrapper function is a subroutine in a software library or a computer program whose main purpose is to call a second subroutine[1] or a system call with little or no additional computation. Wrapper functions are used to make writing computer programs easier by abstracting away the details of a subroutine's underlying implementation. 

The following C code example shows a system call wrapper in AT&T assembler syntax, using the GNU Assembler. Such calls are normally written with the aid of macros; the full code is included for clarity.

The format of basic inline assembly is very straightforward:

asm (<assembly code>);






asm volatile("rdtsc" : "=a" (low), "=d" (high));
/* low and high now contain the lower and upper 32-bits of the 64-bit tsc */

The Linux kernel is written in a mixture of C and assembly, with assembly relegated
to low-level architecture and fast path code.The vast majority of kernel code is pro-
grammed in straight C

When compiling an assembly statement on Linux*, the compiler simply emits the asm-template to the assembly file after making any necessary operand substitutions. The compiler then calls the GNU* assembler to generate machine code. In contrast, on Windows* the compiler itself must assemble the text contained in the asm-template string into machine code. In essence, the compiler contains a built-in assembler. 

The GNU Assembler, commonly known as gas or simply as, its executable name, is the assembler used by the GNU Project. It is the default back-end of GCC. 
