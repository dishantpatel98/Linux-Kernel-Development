The operating system is considered the parts of the system
responsible for basic use and administration.This includes the kernel and device drivers,
boot loader, command shell or other user interface, and basic file and system utilities.
The basics of a Linux system are the kernel, C library, toolchain, and basic system utilities, such as a login process and shell.

The user interface is the outer-most portion of the operating system, the kernel is the innermost. It is the core internals;
the software that provides basic services for all other parts of the system, manages hard-
ware, and distributes system resources.The kernel is sometimes referred to as the
supervisor, core, or internals of the operating system.

Typical components of a kernel are interrupt handlers to service interrupt requests, a scheduler to share processor time
among multiple processes, a memory management system to manage process address
spaces, and system services such as networking and interprocess communication.

Modern systems with protected memory management units, the kernel typically resides in
an elevated system state compared to normal user applications.This includes a protected
memory space and full access to the hardware.This system state and memory space is collectively referred to as kernel-space.
Conversely, user applications execute in user-space.

When executing kernel code, the system is in kernel-space executing in kernel mode.When running a regular process, the system is in user-space executing in user mode.

Applications running on the system communicate with the kernel via system calls.
An application typically calls functions in a library—for example, the C
library—that in turn rely on the system call interface to instruct the kernel to carry out
tasks on the application’s behalf. Some library calls provide many features not found in the
system call, and thus, calling into the kernel is just one step in an otherwise large function.

Still other C library functions, such as strcpy() , should (one hopes) make no direct use
of the kernel at all.

When an application executes a system call, we say that the kernel is
executing on behalf of the application. Furthermore, the application is said to be executing a
system call in kernel-space, and the kernel is running in process context.This relationship—
that applications call into the kernel via the system call interface—is the fundamental manner in 
which applications get work done.

The kernel also manages the system’s hardware. Nearly all architectures, including all
systems that Linux supports, provide the concept of interrupts.When hardware wants to
communicate with the system, it issues an interrupt that literally interrupts the processor,
which in turn interrupts the kernel.A number identifies interrupts and the kernel uses
this number to execute a specific interrupt handler to process and respond to the interrupt.
For example, as you type, the keyboard controller issues an interrupt to let the system
know that there is new data in the keyboard buffer.The kernel notes the interrupt num-
ber of the incoming interrupt and executes the correct interrupt handler.The interrupt
handler processes the keyboard data and lets the keyboard controller know it is ready for
more data.


In many operating systems, including Linux,
the interrupt handlers do not run in a process context. Instead, they run in a special
interrupt context that is not associated with any process.This special context exists solely to
let an interrupt handler quickly respond to an interrupt, and then exit.

In fact, in Linux, we can generalize that each processor is doing exactly one of three things at any given moment:

1)In user-space, executing user code in a process
2)In kernel-space, in process context, executing on behalf of a specific process
3)In kernel-space, in interrupt context, not associated with a process, handling an interrupt


Monolithic Kernel Versus Microkernel Designs

##We can divide kernels into two main schools of design: the monolithic kernel and the micro-
kernel. (A third camp, exokernel, is found primarily in research systems.)

-->Monolithic kernels are the simpler design of the two, and all kernels were designed in this
manner until the 1980s. Monolithic kernels are implemented entirely as a single process
running in a single address space. Consequently, such kernels typically exist on disk as sin-
gle static binaries. All kernel services exist and execute in the large kernel address space.
Communication within the kernel is trivial because everything runs in kernel mode in the
same address space: The kernel can invoke functions directly, as a user-space application
might. Proponents of this model cite the simplicity and performance of the monolithic
approach. Most Unix systems are monolithic in design.

-->Microkernels, on the other hand, are not implemented as a single large process. Instead,
the functionality of the kernel is broken down into separate processes, usually called
servers. Ideally, only the servers absolutely requiring such capabilities run in a privileged exe-
cution mode. The rest of the servers run in user-space. All the servers, though, are sepa-
rated into different address spaces. Therefore, direct function invocation as in monolithic
kernels is not possible. Instead, microkernels communicate via message passing: An inter-
process communication (IPC) mechanism is built into the system, and the various servers
communicate with and invoke “services” from each other by sending messages over the IPC
mechanism. The separation of the various servers prevents a failure in one server from
bringing down another. Likewise, the modularity of the system enables one server to be
swapped out for another.

Linux is a monolithic kernel; that is, the Linux kernel executes in a single address space
entirely in kernel mode. Linux, however, borrows much of the good from microkernels: Linux
boasts a modular design, the capability to preempt itself (called kernel preemption), support
for kernel threads, and the capability to dynamically load separate binaries (kernel modules)
into the kernel image. Conversely, Linux has none of the performance-sapping features that
curse microkernel design: Everything runs in kernel mode, with direct function invocation—
not message passing—the modus of communication. Nonetheless, Linux is modular,
threaded, and the kernel itself is schedulable.

A handful of notable differences exist between the Linux kernel and classic
Unix systems:

1)Linux supports the dynamic loading of kernel modules.Although the Linux kernel
is monolithic, it can dynamically load and unload kernel code on demand.

2)Linux has symmetrical multiprocessor (SMP) support.Although most commercial
variants of Unix now support SMP, most traditional Unix implementations did not.

3)The Linux kernel is preemptive. Unlike traditional Unix variants, the Linux kernel
can preempt a task even as it executes in the kernel. Of the other commercial Unix
implementations, Solaris and IRIX have preemptive kernels, but most Unix kernels
are not preemptive.

4)Linux takes an interesting approach to thread support: It does not differentiate
between threads and normal processes.To the kernel, all processes are the same—
some just happen to share resources.

5)Linux provides an object-oriented device model with device classes, hot-pluggable
events, and a user-space device filesystem (sysfs).
Linux ignores some common Unix features that the kernel developers consider
poorly designed, such as STREAMS, or standards that are impossible to cleanly
implement.

6)Linux is free in every sense of the word.The feature set Linux implements is the
result of the freedom of Linux’s open development model. If a feature is without
merit or poorly thought out, Linux developers are under no obligation to imple-
ment it.To the contrary, Linux has adopted an elitist attitude toward changes: Mod-
ifications must solve a specific real-world problem, derive from a clean design, and
have a solid implementation. Consequently, features of some other modern Unix
variants that are more marketing bullet or one-off requests, such as pageable kernel
memory, have received no consideration.

